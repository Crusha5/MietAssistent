{% macro render_meter_node(meter, level) %}
<div class="meter-node level-{{ level }}" data-meter-id="{{ meter.id }}" data-parent-id="{{ meter.parent_meter_id or '' }}" data-building-id="{{ meter.building_id }}" draggable="true">
    <div class="meter-node-header d-flex justify-content-between align-items-start">
        <div class="d-flex align-items-start">
            <span class="drag-handle me-2" title="Zum Verschieben ziehen"><i class="bi bi-grip-vertical"></i></span>
            <div>
                <div class="d-flex align-items-center mb-1">
                    <span class="fw-semibold me-2">{{ meter.meter_number }}</span>
                    {% if meter.is_virtual_meter %}<span class="badge bg-secondary ms-1">Virtuell</span>{% endif %}
                </div>
                <div class="text-muted small">
                    {{ meter.meter_type.name }}
                    {% if meter.building %}• {{ meter.building.name }}{% endif %}
                    {% if meter.apartment %}• {{ meter.apartment.apartment_number }}{% endif %}
                    {% if meter.description %}• {{ meter.description }}{% endif %}
                </div>
            </div>
        </div>
        <div class="btn-group btn-group-sm">
            <a href="{{ url_for('meters.meter_detail', meter_id=meter.id) }}" class="btn btn-outline-primary" title="Details"><i class="bi bi-eye"></i></a>
            <a href="{{ url_for('meters.edit_meter', meter_id=meter.id) }}" class="btn btn-outline-secondary" title="Bearbeiten"><i class="bi bi-pencil"></i></a>
            <a href="{{ url_for('meters.add_submeter', meter_id=meter.id) }}" class="btn btn-outline-success" title="Unterzähler hinzufügen"><i class="bi bi-plus-lg"></i></a>
            <form action="{{ url_for('meters.archive_meter', meter_id=meter.id) }}" method="POST" class="d-inline">
                <input type="hidden" name="next" value="{{ request.path }}">
                <button type="submit" class="btn btn-outline-warning" onclick="return confirm('Diesen Zähler archivieren?');"><i class="bi bi-archive"></i></button>
            </form>
        </div>
    </div>
    <div class="meter-dropzone" data-parent-id="{{ meter.id }}" data-building-id="{{ meter.building_id }}">
        {% for child in meter._children %}
            {{ render_meter_node(child, level + 1) }}
        {% endfor %}
    </div>
</div>
{% endmacro %}

<div class="meter-tree-widget" data-reorder-endpoint="{{ url_for('meters.reorder_meters') }}" data-feedback-id="{{ feedback_id or 'drag-drop-feedback' }}" data-toggle-id="{{ toggle_id or 'toggle-edit-mode' }}">
    {% if roots_by_building %}
        <div class="hierarchy-tree">
            {% for building_id, roots in roots_by_building.items() %}
                <div class="mb-4 building-section" data-building-id="{{ building_id }}">
                    <div class="d-flex align-items-center mb-2">
                        <i class="bi bi-building text-primary me-2"></i>
                        <h5 class="mb-0">{{ buildings.get(building_id).name if buildings.get(building_id) else 'Gebäude' }}</h5>
                    </div>
                    <div class="meter-dropzone root-dropzone" data-parent-id="" data-building-id="{{ building_id }}">
                        {% for meter in roots %}
                            {{ render_meter_node(meter, 0) }}
                        {% endfor %}
                    </div>
                </div>
            {% endfor %}
        </div>
    {% else %}
        <div class="text-center py-5">
            <i class="bi bi-diagram-3 display-1 text-muted"></i>
            <h4 class="text-muted mt-3">Keine Zähler gefunden</h4>
            <p class="text-muted">Legen Sie Ihren ersten Hauptzähler an.</p>
            <a href="/meters/create" class="btn btn-primary">
                <i class="bi bi-plus-circle me-1"></i>Ersten Hauptzähler anlegen
            </a>
        </div>
    {% endif %}
</div>

<style>
.hierarchy-tree { max-width: 100%; }
.meter-node { margin-bottom: 0.5rem; padding: 0.75rem; border: 1px solid var(--bs-border-color); border-left: 4px solid #1e40af; border-radius: 0.5rem; background: var(--bs-card-bg); transition: all 0.2s ease; }
.meter-node.level-1 { border-left-color: #0f766e; margin-left: 1.25rem; }
.meter-node.level-2 { border-left-color: #dc2626; margin-left: 2rem; }
.meter-node.level-3 { border-left-color: #f97316; margin-left: 2.75rem; }
.meter-node:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.1); transform: translateY(-1px); }
.meter-node-header { gap: 0.5rem; }
.drag-handle { cursor: grab; color: var(--bs-secondary-color); }
.dragging { opacity: 0.5; }
.meter-dropzone { margin-left: 0.75rem; padding-left: 0.75rem; border-left: 2px dashed transparent; min-height: 0.5rem; }
.meter-dropzone.drop-target { border-left-color: #60a5fa; background: rgba(96,165,250,0.08); }
.meter-edit-mode .meter-dropzone { border-left-color: rgba(0,0,0,0.05); }
.root-dropzone { padding-left: 0; border-left: none; }
[data-bs-theme="dark"] .meter-node { background: #0f172a; border-color: #1f2937; }
[data-bs-theme="dark"] .meter-dropzone.drop-target { background: rgba(96,165,250,0.1); border-left-color: #60a5fa; }
</style>

<script>
(() => {
    const widgets = document.querySelectorAll('.meter-tree-widget');
    widgets.forEach(widget => {
        const feedbackId = widget.dataset.feedbackId;
        const feedback = feedbackId ? document.getElementById(feedbackId) : null;
        const reorderEndpoint = widget.dataset.reorderEndpoint;
        const toggle = document.getElementById(widget.dataset.toggleId || 'toggle-edit-mode');
        let editMode = false;
        let draggedNode = null;

        function setFeedback(message, type = 'info') {
            if (!feedback) return;
            feedback.className = `alert alert-${type}`;
            feedback.textContent = message;
            feedback.classList.remove('d-none');
        }

        function clearFeedback() {
            if (!feedback) return;
            feedback.classList.add('d-none');
            feedback.textContent = '';
        }

        function toggleEdit() {
            editMode = !editMode;
            widget.classList.toggle('meter-edit-mode', editMode);
            if (toggle) {
                toggle.innerHTML = editMode
                    ? '<i class="bi bi-check2-square me-1"></i>Bearbeitungsmodus beenden'
                    : '<i class="bi bi-arrows-move me-1"></i>Drag & Drop aktivieren';
            }
            setFeedback(editMode ? 'Ziehen Sie einen Zähler auf einen anderen, um ihn neu anzuordnen.' : '');
            if (!editMode) {
                clearFeedback();
            }
        }

        function isAncestor(node, potentialChild) {
            return node && node.contains(potentialChild);
        }

        function rebuildPayload(zones) {
            const seen = new Set();
            const items = [];
            zones.forEach(zone => {
                if (!zone || seen.has(zone)) return;
                seen.add(zone);
                const parentId = zone.dataset.parentId || null;
                const siblings = Array.from(zone.querySelectorAll(':scope > .meter-node'));
                siblings.forEach((node, index) => {
                    items.push({
                        id: node.dataset.meterId,
                        parent_id: parentId,
                        position: index,
                    });
                });
            });
            return items;
        }

        async function persistOrder(zones) {
            const items = rebuildPayload(zones);
            if (!items.length) return;
            const response = await fetch(reorderEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ items }),
            });
            const result = await response.json();
            if (!response.ok) {
                throw new Error(result.error || 'Speichern fehlgeschlagen');
            }
            setFeedback('Hierarchie aktualisiert.', 'success');
        }

        function handleDragStart(event) {
            if (!editMode) {
                event.preventDefault();
                return;
            }
            draggedNode = event.currentTarget;
            draggedNode.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', draggedNode.dataset.meterId);
        }

        function handleDragEnd() {
            if (draggedNode) {
                draggedNode.classList.remove('dragging');
            }
            draggedNode = null;
            widget.querySelectorAll('.meter-dropzone').forEach(z => z.classList.remove('drop-target'));
        }

        function handleDragOver(event) {
            if (!editMode || !draggedNode) return;
            const zone = event.currentTarget;
            const sameBuilding = zone.dataset.buildingId === draggedNode.dataset.buildingId;
            const insideDragged = isAncestor(draggedNode, zone);
            if (sameBuilding && !insideDragged) {
                event.preventDefault();
                zone.classList.add('drop-target');
            }
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('drop-target');
        }

        async function handleDrop(event) {
            if (!editMode || !draggedNode) return;
            event.preventDefault();
            const zone = event.currentTarget;
            zone.classList.remove('drop-target');

            if (isAncestor(draggedNode, zone)) {
                setFeedback('Ein Zähler kann nicht unter sich selbst einsortiert werden.', 'warning');
                return;
            }

            if (zone.dataset.buildingId !== draggedNode.dataset.buildingId) {
                setFeedback('Zähler können nur innerhalb eines Gebäudes verschoben werden.', 'danger');
                return;
            }

            const targetParentId = zone.dataset.parentId || null;
            const previousParentId = draggedNode.dataset.parentId || '';
            const previousZone = widget.querySelector(`.meter-dropzone[data-parent-id="${previousParentId}"][data-building-id="${draggedNode.dataset.buildingId}"]`);

            zone.appendChild(draggedNode);
            draggedNode.dataset.parentId = targetParentId || '';

            try {
                await persistOrder([previousZone, zone]);
            } catch (err) {
                setFeedback(err.message, 'danger');
            }
        }

        toggle?.addEventListener('click', toggleEdit);

        widget.querySelectorAll('.meter-node').forEach(node => {
            node.addEventListener('dragstart', handleDragStart);
            node.addEventListener('dragend', handleDragEnd);
        });

        widget.querySelectorAll('.meter-dropzone').forEach(zone => {
            zone.addEventListener('dragover', handleDragOver);
            zone.addEventListener('dragleave', handleDragLeave);
            zone.addEventListener('drop', handleDrop);
        });
    });
})();
</script>
